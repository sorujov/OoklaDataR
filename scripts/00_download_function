# =============================================================================
# Modular Function: Process Ookla Data for Any Country/Quarter
# =============================================================================

library(tidyverse)
library(arrow)
library(sf)
library(here)
library(httr)
library(rnaturalearth)

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

# Generate quadkey prefixes for a given bounding box
generate_quadkey_prefixes <- function(bbox, zoom = 5, prefix_length = 4) {
  latlon_to_quadkey <- function(lat, lon, zoom) {
    lat_rad <- lat * pi / 180
    n <- 2^zoom
    x <- floor((lon + 180) / 360 * n)
    y <- floor((1 - log(tan(lat_rad) + 1/cos(lat_rad)) / pi) / 2 * n)
    
    quadkey <- ""
    for (i in zoom:1) {
      digit <- 0
      mask <- bitwShiftL(1, i - 1)
      if (bitwAnd(as.integer(x), as.integer(mask)) != 0) digit <- digit + 1
      if (bitwAnd(as.integer(y), as.integer(mask)) != 0) digit <- digit + 2
      quadkey <- paste0(quadkey, digit)
    }
    return(quadkey)
  }
  
  lat_seq <- seq(bbox$ymin, bbox$ymax, by = 0.5)
  lon_seq <- seq(bbox$xmin, bbox$xmax, by = 0.5)
  
  grid <- expand.grid(lat = lat_seq, lon = lon_seq)
  quadkeys <- mapply(latlon_to_quadkey, grid$lat, grid$lon, 
                     MoreArgs = list(zoom = zoom))
  
  unique(substr(quadkeys, 1, prefix_length))
}

# =============================================================================
# MAIN PROCESSING FUNCTION
# =============================================================================

process_ookla_data <- function(
    country_code,           # e.g., "AZ", "AM", "RU"
    year,                   # e.g., 2019, 2024
    quarter,                # 1, 2, 3, or 4
    network_type,           # "fixed" or "mobile"
    country_bbox = NULL,    # Optional: list(xmin, ymin, xmax, ymax)
    cis_countries = NULL,   # Optional: pre-loaded sf object with boundaries
    config = NULL,          # Optional: config with s3_prefix, etc.
    s3_base = "https://ookla-open-data.s3.amazonaws.com",
    save_output = FALSE,    # Whether to save RDS file
    output_dir = NULL,      # Where to save output
    verbose = TRUE          # Print progress messages
) {
  
  # Start timing
  start_time <- Sys.time()
  
  if (verbose) {
    cat("\n")
    cat("╔═══════════════════════════════════════════════════════════════════╗\n")
    cat("│ Processing:", country_code, year, "Q", quarter, toupper(network_type), 
        "                   │\n")
    cat("╚═══════════════════════════════════════════════════════════════════╝\n\n")
  }
  
  # Load config if not provided
  if (is.null(config)) {
    config <- list(
      s3_prefix = "parquet/performance/",
      country_names = c(
        AZ = "Azerbaijan", AM = "Armenia", BY = "Belarus", 
        GE = "Georgia", KZ = "Kazakhstan", KG = "Kyrgyzstan",
        MD = "Moldova", RU = "Russia", TJ = "Tajikistan",
        TM = "Turkmenistan", UA = "Ukraine", UZ = "Uzbekistan"
      )
    )
  }
  
  # Load CIS countries boundaries if not provided
  if (is.null(cis_countries)) {
    boundaries_file <- here("data", "boundaries", "cis_countries.rds")
    
    if (file.exists(boundaries_file)) {
      cis_countries <- readRDS(boundaries_file)
    } else {
      if (verbose) cat("Loading country boundaries from Natural Earth...\n")
      world <- ne_countries(scale = "medium", returnclass = "sf")
      cis_countries <- world %>%
        filter(iso_a2 %in% names(config$country_names)) %>%
        select(country = name, iso_a2, geometry) %>%
        st_make_valid()
      
      dir.create(here("data", "boundaries"), recursive = TRUE, showWarnings = FALSE)
      saveRDS(cis_countries, boundaries_file)
    }
  }
  
  # Get country boundary
  country_boundary <- cis_countries %>% filter(iso_a2 == country_code)
  
  if (nrow(country_boundary) == 0) {
    stop("Country code '", country_code, "' not found in boundaries")
  }
  
  # Get or compute bounding box
  if (is.null(country_bbox)) {
    bbox_sf <- st_bbox(country_boundary)
    country_bbox <- list(
      xmin = as.numeric(bbox_sf["xmin"]),
      ymin = as.numeric(bbox_sf["ymin"]),
      xmax = as.numeric(bbox_sf["xmax"]),
      ymax = as.numeric(bbox_sf["ymax"])
    )
  }
  
  if (verbose) {
    cat("Country:", config$country_names[country_code], "\n")
    cat("BBox: Lon [", round(country_bbox$xmin, 2), ",", 
        round(country_bbox$xmax, 2), "] Lat [", 
        round(country_bbox$ymin, 2), ",", round(country_bbox$ymax, 2), "]\n\n")
  }
  
  # Generate quadkey prefixes for old schema
  quadkey_prefixes <- generate_quadkey_prefixes(country_bbox)
  
  if (verbose) {
    cat("Generated", length(quadkey_prefixes), "quadkey prefixes\n\n")
  }
  
  # Build S3 URI
  quarter_start <- sprintf("%s-%02d-01", year, ((quarter - 1) * 3) + 1)
  s3_uri <- paste0(
    "s3://ookla-open-data/", config$s3_prefix,
    "type=", network_type,
    "/year=", year,
    "/quarter=", quarter, "/",
    quarter_start, "_performance_", network_type, "_tiles.parquet"
  )
  
  if (verbose) cat("S3 URI:", s3_uri, "\n\n")
  
  # Download and filter data
  tryCatch({
    if (verbose) cat("Opening dataset...\n")
    ds <- open_dataset(s3_uri, format = "parquet")
    
    # Check schema
    schema_cols <- names(ds$schema)
    has_tile_coords <- all(c("tile_x", "tile_y") %in% schema_cols)
    
    download_start <- Sys.time()
    
    if (has_tile_coords) {
      # NEW SCHEMA: Use tile_x/tile_y bbox
      if (verbose) cat("  New schema: Using tile_x/tile_y bbox filter...\n")
      tiles <- ds %>%
        filter(
          tile_x >= country_bbox$xmin & tile_x <= country_bbox$xmax,
          tile_y >= country_bbox$ymin & tile_y <= country_bbox$ymax
        ) %>%
        collect()
    } else {
      # OLD SCHEMA: Use quadkey prefix filter
      if (verbose) cat("  Old schema: Using quadkey prefix filter...\n")
      
      prefix_length <- nchar(quadkey_prefixes[1])
      
      tiles <- ds %>%
        mutate(qk_prefix = substr(quadkey, 1, prefix_length)) %>%
        filter(qk_prefix %in% quadkey_prefixes) %>%
        select(-qk_prefix) %>%
        collect()
    }
    
    download_time <- as.numeric(difftime(Sys.time(), download_start, units = "secs"))
    
    if (verbose) {
      cat("✓ Downloaded", format(nrow(tiles), big.mark = ","), "tiles in",
          round(download_time, 1), "seconds\n")
      cat("  Size:", round(object.size(tiles) / 1024^2, 1), "MB\n\n")
    }
    
    if (nrow(tiles) == 0) {
      warning("No tiles found for ", country_code, " ", year, " Q", quarter)
      return(NULL)
    }
    
    # Convert to spatial
    if (verbose) cat("Converting to spatial features...\n")
    conversion_start <- Sys.time()
    
    tiles_sf <- st_as_sf(tiles, wkt = "tile", crs = 4326)
    tiles_sf <- st_make_valid(tiles_sf)
    
    conversion_time <- as.numeric(difftime(Sys.time(), conversion_start, units = "secs"))
    if (verbose) cat("✓ Converted in", round(conversion_time, 1), "seconds\n\n")
    
    # Precise intersection with country boundary
    if (verbose) cat("Refining with precise boundary...\n")
    intersection_start <- Sys.time()
    
    tiles_final <- st_intersection(tiles_sf, country_boundary)
    
    intersection_time <- as.numeric(difftime(Sys.time(), intersection_start, units = "secs"))
    
    if (verbose) {
      cat("✓ Final tiles:", format(nrow(tiles_final), big.mark = ","), 
          "in", round(intersection_time, 1), "seconds\n\n")
    }
    
    # Calculate statistics
    if (verbose) cat("Computing statistics...\n")
    
    stats <- tiles_final %>%
      st_drop_geometry() %>%
      summarise(
        country_code = country_code,
        country_name = config$country_names[country_code],
        year = year,
        quarter = quarter,
        network_type = network_type,
        download_mbps = round(median(avg_d_kbps / 1000, na.rm = TRUE), 1),
        upload_mbps = round(median(avg_u_kbps / 1000, na.rm = TRUE), 1),
        latency_ms = round(median(avg_lat_ms, na.rm = TRUE), 0),
        tile_count = n(),
        total_tests = sum(tests, na.rm = TRUE)
      )
    
    # Save output if requested
    if (save_output && !is.null(output_dir)) {
      dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
      output_file <- file.path(
        output_dir,
        paste0(country_code, "_", year, "Q", quarter, "_", network_type, ".rds")
      )
      saveRDS(tiles_final, output_file)
      if (verbose) cat("✓ Saved to:", output_file, "\n")
    }
    
    # Print results
    if (verbose) {
      total_time <- as.numeric(difftime(Sys.time(), start_time, units = "secs"))
      
      cat("\n")
      cat("=", rep("=", 70), "=\n", sep = "")
      cat("RESULTS -", toupper(network_type), "\n")
      cat("=", rep("=", 70), "=\n", sep = "")
      cat("  Download:", stats$download_mbps, "Mbps\n")
      cat("  Upload:", stats$upload_mbps, "Mbps\n")
      cat("  Latency:", stats$latency_ms, "ms\n")
      cat("  Tests:", format(stats$total_tests, big.mark = ","), "\n")
      cat("  Tiles:", format(stats$tile_count, big.mark = ","), "\n")
      cat("  Total time:", round(total_time, 1), "seconds\n")
      cat("=", rep("=", 70), "=\n\n", sep = "")
    }
    
    return(stats)
    
  }, error = function(e) {
    warning("Error processing ", country_code, " ", year, " Q", quarter, 
            " ", network_type, ": ", conditionMessage(e))
    return(NULL)
  })
}

# =============================================================================
# EXAMPLE USAGE
# =============================================================================

# Test single country/quarter
result <- process_ookla_data(
  country_code = "AZ",
  year = 2021,
  quarter = 2,
  network_type = "fixed",
  save_output = TRUE,
  output_dir = here("data", "temp_test"),
  verbose = TRUE
)

print(result)

# Process multiple combinations
test_params <- expand.grid(
  country_code = c("AZ", "AM", "GE"),
  year = c(2019, 2021, 2024),
  quarter = c(2, 3),
  network_type = c("fixed", "mobile"),
  stringsAsFactors = FALSE
)

# Process sequentially (for testing)
results_list <- list()

for (i in 1:nrow(test_params)) {
  result <- process_ookla_data(
    country_code = test_params$country_code[i],
    year = test_params$year[i],
    quarter = test_params$quarter[i],
    network_type = test_params$network_type[i],
    save_output = FALSE,
    verbose = FALSE
  )
  
  if (!is.null(result)) {
    results_list[[i]] <- result
  }
}

# Combine all results
all_results <- bind_rows(results_list)
print(all_results)

# Save aggregated results
write_csv(all_results, here("data", "aggregated", "test_results.csv"))
